

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Layers &mdash; PaddlePaddle  文档</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
  
        <link rel="index" title="索引"
              href="../../../genindex.html"/>
        <link rel="search" title="搜索" href="../../../search.html"/>
    <link rel="top" title="PaddlePaddle  文档" href="../../../index.html"/>
        <link rel="up" title="Fluid" href="../fluid.html"/>
        <link rel="next" title="DataFeeder" href="data_feeder.html"/>
        <link rel="prev" title="Fluid" href="../fluid.html"/> 

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/perfect-scrollbar/0.6.14/css/perfect-scrollbar.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/override.css" type="text/css" />
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?b9a314ab40d04d805655aab1deee08ba";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>

  

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  
  <header class="site-header">
    <div class="site-logo">
      <a href="/"><img src="../../../_static/images/PP_w.png"></a>
    </div>
    <div class="site-nav-links">
      <div class="site-menu">
        <a class="fork-on-github" href="https://github.com/PaddlePaddle/Paddle" target="_blank"><i class="fa fa-github"></i>Fork me on Github</a>
        <div class="language-switcher dropdown">
          <a type="button" data-toggle="dropdown">
            <span>English</span>
            <i class="fa fa-angle-up"></i>
            <i class="fa fa-angle-down"></i>
          </a>
          <ul class="dropdown-menu">
            <li><a href="/doc_cn">中文</a></li>
            <li><a href="/doc">English</a></li>
          </ul>
        </div>
        <ul class="site-page-links">
          <li><a href="/">Home</a></li>
        </ul>
      </div>
      <div class="doc-module">
        
        <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../getstarted/index_cn.html">新手入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto/index_cn.html">进阶指南</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index_cn.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/index_cn.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mobile/index_cn.html">MOBILE</a></li>
</ul>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>        
      </div>
    </div>
  </header>
  
  <div class="main-content-wrap">

    
    <nav class="doc-menu-vertical" role="navigation">
        
          
          <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../getstarted/index_cn.html">新手入门</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../getstarted/build_and_install/index_cn.html">安装与编译</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../getstarted/build_and_install/pip_install_cn.html">使用pip安装</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../getstarted/build_and_install/docker_install_cn.html">使用Docker安装运行</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../howto/dev/build_cn.html">用Docker编译和测试PaddlePaddle</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../getstarted/build_and_install/build_from_source_cn.html">从源码编译</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../getstarted/concepts/use_concepts_cn.html">基本使用概念</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto/index_cn.html">进阶指南</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../howto/usage/cmd_parameter/index_cn.html">设置命令行参数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../howto/usage/cmd_parameter/use_case_cn.html">使用案例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../howto/usage/cmd_parameter/arguments_cn.html">参数概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../howto/usage/cmd_parameter/detail_introduction_cn.html">细节描述</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto/usage/cluster/cluster_train_cn.html">分布式训练</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../howto/usage/cluster/fabric_cn.html">fabric集群</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../howto/usage/cluster/openmpi_cn.html">openmpi集群</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../howto/usage/cluster/k8s_cn.html">kubernetes单机</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../howto/usage/cluster/k8s_distributed_cn.html">kubernetes distributed分布式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../howto/usage/cluster/k8s_aws_cn.html">AWS上运行kubernetes集群训练</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto/dev/contribute_to_paddle_cn.html">如何贡献代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto/dev/write_docs_cn.html">如何贡献/修改文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto/deep_model/rnn/index_cn.html">RNN相关模型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../howto/deep_model/rnn/rnn_config_cn.html">RNN配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../howto/deep_model/rnn/recurrent_group_cn.html">Recurrent Group教程</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../howto/deep_model/rnn/hierarchical_layer_cn.html">支持双层序列作为输入的Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../howto/deep_model/rnn/hrnn_rnn_api_compare_cn.html">单双层RNN API对比介绍</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../howto/optimization/gpu_profiling_cn.html">GPU性能分析与调优</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index_cn.html">API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../model_configs.html">模型配置</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../config/activation.html">Activation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../config/layer.html">Layers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../config/evaluators.html">Evaluators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../config/optimizer.html">Optimizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../config/pooling.html">Pooling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../config/networks.html">Networks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../config/attr.html">Parameter Attribute</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../data.html">数据访问</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../data/data_reader.html">Data Reader Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../data/image.html">Image Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../data/dataset.html">Dataset</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../run_logic.html">训练与应用</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../fluid.html">Fluid</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Layers</a></li>
<li class="toctree-l3"><a class="reference internal" href="data_feeder.html">DataFeeder</a></li>
<li class="toctree-l3"><a class="reference internal" href="executor.html">Executor</a></li>
<li class="toctree-l3"><a class="reference internal" href="initializer.html">Initializer</a></li>
<li class="toctree-l3"><a class="reference internal" href="evaluator.html">Evaluator</a></li>
<li class="toctree-l3"><a class="reference internal" href="nets.html">Nets</a></li>
<li class="toctree-l3"><a class="reference internal" href="optimizer.html">Optimizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="param_attr.html">ParamAttr</a></li>
<li class="toctree-l3"><a class="reference internal" href="profiler.html">Profiler</a></li>
<li class="toctree-l3"><a class="reference internal" href="regularizer.html">Regularizer</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/index_cn.html">FAQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../faq/build_and_install/index_cn.html">编译安装与单元测试</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../faq/model/index_cn.html">模型配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../faq/parameter/index_cn.html">参数设置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../faq/local/index_cn.html">本地训练与预测</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../faq/cluster/index_cn.html">集群训练与预测</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../mobile/index_cn.html">MOBILE</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../mobile/cross_compiling_for_android_cn.html">Android平台编译指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../mobile/cross_compiling_for_ios_cn.html">iOS平台编译指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../mobile/cross_compiling_for_raspberry_cn.html">Raspberry Pi平台编译指南</a></li>
</ul>
</li>
</ul>

        
    </nav>
    
    <section class="doc-content-wrap">

      

 







<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
      
        <li><a href="../../index_cn.html">API</a> > </li>
      
        <li><a href="../fluid.html">Fluid</a> > </li>
      
    <li>Layers</li>
  </ul>
</div>
      
      <div class="wy-nav-content" id="doc-content">
        <div class="rst-content">
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="layers">
<h1>Layers<a class="headerlink" href="#layers" title="永久链接至标题">¶</a></h1>
<div class="section" id="fc">
<h2>fc<a class="headerlink" href="#fc" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">fc</code><span class="sig-paren">(</span><em>input</em>, <em>size</em>, <em>num_flatten_dims=1</em>, <em>param_attr=None</em>, <em>bias_attr=None</em>, <em>act=None</em>, <em>name=None</em><span class="sig-paren">)</span></dt>
<dd><p><strong>Fully Connected Layer</strong></p>
<p>The fully connected layer can take multiple tensors as its inputs. It
creates a variable (one for each input tensor) called weights for each input
tensor, which represents a fully connected weight matrix from each input
unit to each output unit. The fully connected layer multiplies each input
tensor with its coresponding weight to produce an output Tensor. If
multiple input tensors are given, the results of multiple multiplications
will be sumed up. If bias_attr is not None, a biases variable will be
created and added to the output. Finally, if activation is not None,
it will be applied to the output as well.</p>
<p>This process can be formulated as follows:</p>
<div class="math">
\[Out = Act({\sum_{i=0}^{N-1}W_iX_i + b})\]</div>
<p>In the above equation:</p>
<ul class="simple">
<li><span class="math">\(N\)</span>: Number of the input.</li>
<li><span class="math">\(X_i\)</span>: The input tensor.</li>
<li><span class="math">\(W\)</span>: The weights created by this layer.</li>
<li><span class="math">\(b\)</span>: The bias parameter created by this layer (if needed).</li>
<li><span class="math">\(Act\)</span>: The activation funtion.</li>
<li><span class="math">\(Out\)</span>: The output tensor.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>Variable|list</em>) &#8211; The input tensor(s) to the fully connected layer.</li>
<li><strong>size</strong> (<em>int</em>) &#8211; The number of output units in the fully connected layer.</li>
<li><strong>num_flatten_dims</strong> (<em>int</em>) &#8211; The fc layer can accept an input tensor with more
than two dimensions. If this happens, the
multidimensional tensor will first be flattened
into a 2-dimensional matrix. The parameter
<cite>num_flatten_dims</cite> determines how the input tensor
is flattened: the first <cite>num_flatten_dims</cite>
dimensions will be flatten to form the first
dimension of the final matrix (height of the
matrix), and the rest <cite>rank(X) - num_col_dims</cite>
dimensions are flattened to form the second
dimension of the final matrix (width of the matrix).
For example, suppose <cite>X</cite> is a 6-dimensional tensor
with a shape [2, 3, 4, 5, 6], and
<cite>x_num_col_dims</cite> = 3. Then, the flattened matrix
will have a shape [2 x 3 x 4, 5 x 6] = [24, 30].
By default, <cite>x_num_col_dims</cite> is set to 1.</li>
<li><strong>param_attr</strong> (<em>ParamAttr|list</em>) &#8211; The parameter attribute for learnable
parameters/weights of the fully connected
layer.</li>
<li><strong>param_initializer</strong> (<em>ParamAttr|list</em>) &#8211; The initializer used for the
weight/parameter. If set None,
XavierInitializer() will be used.</li>
<li><strong>bias_attr</strong> (<em>ParamAttr|list</em>) &#8211; The parameter attribute for the bias parameter
for this layer. If set None, no bias will be
added to the output units.</li>
<li><strong>bias_initializer</strong> (<em>ParamAttr|list</em>) &#8211; The initializer used for the bias.
If set None, then ConstantInitializer()
will be used.</li>
<li><strong>act</strong> (<em>str</em>) &#8211; Activation to be applied to the output of the fully connected
layer.</li>
<li><strong>name</strong> (<em>str</em>) &#8211; Name/alias of the fully connected layer.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The output tensor variable.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first">Variable</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> &#8211; If rank of the input tensor is less than 2.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
<span class="n">fc</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">act</span><span class="o">=</span><span class="s2">&quot;tanh&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="embedding">
<h2>embedding<a class="headerlink" href="#embedding" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">embedding</code><span class="sig-paren">(</span><em>input</em>, <em>size</em>, <em>is_sparse=False</em>, <em>param_attr=None</em>, <em>dtype='float32'</em><span class="sig-paren">)</span></dt>
<dd><p><strong>Embedding Layer</strong></p>
<p>This layer is used to lookup a vector of IDs, provided by <em>input</em>, in a lookup table.
The result of this lookup is the embedding of each ID in the <em>input</em>.</p>
<p>All the input variables are passed in as local variables to the LayerHelper
constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>Variable</em>) &#8211; Input to the function</li>
<li><strong>size</strong> (<em>tuple|list|None</em>) &#8211; Shape of the look up table parameter</li>
<li><strong>is_sparse</strong> (<em>bool</em>) &#8211; Boolean flag that specifying whether the input is sparse</li>
<li><strong>param_attr</strong> (<em>ParamAttr</em>) &#8211; Parameters for this layer</li>
<li><strong>dtype</strong> (<em>np.dtype|core.DataType|str</em>) &#8211; The type of data : float32, float_16, int etc</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The tensor variable storing the embeddings of the                   supplied inputs.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">dict_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ids&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="n">fc</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">embedding</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="n">dict_size</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="dynamic-lstm">
<h2>dynamic_lstm<a class="headerlink" href="#dynamic-lstm" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">dynamic_lstm</code><span class="sig-paren">(</span><em>input</em>, <em>size</em>, <em>param_attr=None</em>, <em>bias_attr=None</em>, <em>use_peepholes=True</em>, <em>is_reverse=False</em>, <em>gate_activation='sigmoid'</em>, <em>cell_activation='tanh'</em>, <em>candidate_activation='tanh'</em>, <em>dtype='float32'</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</div>
<div class="section" id="data">
<h2>data<a class="headerlink" href="#data" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">data</code><span class="sig-paren">(</span><em>name</em>, <em>shape</em>, <em>append_batch_size=True</em>, <em>dtype='float32'</em>, <em>lod_level=0</em>, <em>type=VarType.LOD_TENSOR</em>, <em>stop_gradient=True</em><span class="sig-paren">)</span></dt>
<dd><p><strong>Data Layer</strong></p>
<p>This function takes in the input and based on whether data has
to be returned back as a minibatch, it creates the global variable using
the helper functions. The global variables can be accessed by all the
following operations and layers in the graph.</p>
<p>All the input variables of this function are passed in as local variables
to the LayerHelper constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>str</em>) &#8211; The name/alias of the function</li>
<li><strong>shape</strong> (<em>list</em>) &#8211; Tuple declaring the shape.</li>
<li><strong>append_batch_size</strong> (<em>bool</em>) &#8211; Whether or not to append the data as a batch.</li>
<li><strong>dtype</strong> (<em>int|float</em>) &#8211; The type of data : float32, float_16, int etc</li>
<li><strong>type</strong> (<em>VarType</em>) &#8211; The output type. By default it is LOD_TENSOR.</li>
<li><strong>lod_level</strong> (<em>int</em>) &#8211; The LoD Level. 0 means the input data is not a sequence.</li>
<li><strong>main_program</strong> (<em>Program</em>) &#8211; Name of the main program that calls this</li>
<li><strong>startup_program</strong> (<em>Program</em>) &#8211; Name of the startup program</li>
<li><strong>stop_gradient</strong> (<em>bool</em>) &#8211; A boolean that mentions whether gradient should flow.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The global variable that gives access to the data.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">784</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="mean">
<h2>mean<a class="headerlink" href="#mean" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">mean</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Mean Operator.</p>
<p>Out is a scalar which is the mean of all elements in X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>x</strong> &#8211; The input of mean op
Duplicable: False  Optional: False</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">The output of mean op</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="mul">
<h2>mul<a class="headerlink" href="#mul" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">mul</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Mul Operator.</p>
<p>This operator is used to perform matrix multiplication for input $X$ and $Y$.</p>
<p>The equation is:</p>
<p>$$Out = X * Y$$</p>
<p>Both the input $X$ and $Y$ can carry the LoD (Level of Details) information,
or not. But the output only shares the LoD information with input $X$.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; (Tensor), The first input tensor of mul op.
Duplicable: False  Optional: False</li>
<li><strong>y</strong> &#8211; (Tensor), The second input tensor of mul op.
Duplicable: False  Optional: False</li>
<li><strong>x_num_col_dims</strong> (<em>INT</em>) &#8211; (int, default 1), The mul_op can take tensors with more than two
dimensions as its inputs. If the input $X$ is a tensor with more
than two dimensions, $X$ will be flattened into a two-dimensional
matrix first. The flattening rule is: the first <cite>num_col_dims</cite>
will be flattened to form the first dimension of the final matrix
(the height of the matrix), and the rest <cite>rank(X) - num_col_dims</cite>
dimensions are flattened to form the second dimension of the final
matrix (the width of the matrix). As a result, height of the
flattened matrix is equal to the product of $X$&#8217;s first
<cite>x_num_col_dims</cite> dimensions&#8217; sizes, and width of the flattened
matrix is equal to the product of $X$&#8217;s last <cite>rank(x) - num_col_dims</cite>
dimensions&#8217; size. For example, suppose $X$ is a 6-dimensional
tensor with the shape [2, 3, 4, 5, 6], and <cite>x_num_col_dims</cite> = 3.
Thus, the flattened matrix will have a shape [2 x 3 x 4, 5 x 6] =
[24, 30].</li>
<li><strong>y_num_col_dims</strong> (<em>INT</em>) &#8211; (int, default 1), The mul_op can take tensors with more than two,
dimensions as its inputs. If the input $Y$ is a tensor with more
than two dimensions, $Y$ will be flattened into a two-dimensional
matrix first. The attribute <cite>y_num_col_dims</cite> determines how $Y$ is
flattened. See comments of <cite>x_num_col_dims</cite> for more details.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(Tensor), The output tensor of mul op.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="elementwise-add">
<h2>elementwise_add<a class="headerlink" href="#elementwise-add" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">elementwise_add</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Limited Elementwise Add Operator.</p>
<p>The equation is:</p>
<p>$Out = X + Y$</p>
<p>X is a tensor of any dimension and the dimensions of tensor Y must be smaller than
or equal to the dimensions of X.</p>
<p>There are two cases for this operator:
1. The shape of Y is same with X;
2. The shape of Y is a subset of X.</p>
<p>For case 2:
Y will be broadcasted to match the shape of X and axis should be
the starting dimension index for broadcasting Y onto X.</p>
<p class="rubric">example</p>
<p>shape(X) = (2, 3, 4, 5), shape(Y) = (,)
shape(X) = (2, 3, 4, 5), shape(Y) = (5,)
shape(X) = (2, 3, 4, 5), shape(Y) = (4, 5)
shape(X) = (2, 3, 4, 5), shape(Y) = (3, 4), with axis=1
shape(X) = (2, 3, 4, 5), shape(Y) = (2), with axis=0</p>
<p>Both the input X and Y can carry the LoD (Level of Details) information,
or not. But the output only shares the LoD information with input X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; (Tensor) The first input tensor of elementwise op
Duplicable: False  Optional: False</li>
<li><strong>y</strong> &#8211; (Tensor) The second input tensor of elementwise op
Duplicable: False  Optional: False</li>
<li><strong>axis</strong> (<em>INT</em>) &#8211; (int, default -1) The starting dimension index for broadcasting Y onto X</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">The output of elementwise op</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="elementwise-div">
<h2>elementwise_div<a class="headerlink" href="#elementwise-div" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">elementwise_div</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Limited Elementwise Div Operator.</p>
<p>The equation is:</p>
<p>$Out = X / Y$</p>
<p>X is a tensor of any dimension and the dimensions of tensor Y must be smaller than
or equal to the dimensions of X.</p>
<p>There are two cases for this operator:
1. The shape of Y is same with X;
2. The shape of Y is a subset of X.</p>
<p>For case 2:
Y will be broadcasted to match the shape of X and axis should be
the starting dimension index for broadcasting Y onto X.</p>
<p class="rubric">example</p>
<p>shape(X) = (2, 3, 4, 5), shape(Y) = (,)
shape(X) = (2, 3, 4, 5), shape(Y) = (5,)
shape(X) = (2, 3, 4, 5), shape(Y) = (4, 5)
shape(X) = (2, 3, 4, 5), shape(Y) = (3, 4), with axis=1
shape(X) = (2, 3, 4, 5), shape(Y) = (2), with axis=0</p>
<p>Both the input X and Y can carry the LoD (Level of Details) information,
or not. But the output only shares the LoD information with input X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; (Tensor) The first input tensor of elementwise op
Duplicable: False  Optional: False</li>
<li><strong>y</strong> &#8211; (Tensor) The second input tensor of elementwise op
Duplicable: False  Optional: False</li>
<li><strong>axis</strong> (<em>INT</em>) &#8211; (int, default -1) The starting dimension index for broadcasting Y onto X</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">The output of elementwise op</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="dropout">
<h2>dropout<a class="headerlink" href="#dropout" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">dropout</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Dropout Operator.</p>
<p>Dropout refers to randomly dropping out units in a nerual network. It is a
regularization technique for reducing overfitting by preventing neuron
co-adaption during training. The dropout operator randomly set (according to
the given dropout probability) the outputs of some units to zero, while others
are set equal to their corresponding inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; The input of dropout op.
Duplicable: False  Optional: False</li>
<li><strong>dropout_prob</strong> (<em>FLOAT</em>) &#8211; Probability of setting units to zero.</li>
<li><strong>is_test</strong> (<em>BOOLEAN</em>) &#8211; True if in test phase.</li>
<li><strong>seed</strong> (<em>INT</em>) &#8211; Dropout random seed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">The output of dropout op.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="reshape">
<h2>reshape<a class="headerlink" href="#reshape" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">reshape</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Reshape Operator.</p>
<p>Reshape Input(X) into the shape specified by Attr(shape).</p>
<p>An example:
Given a 2-D tensor X with 2 rows and 2 columns</p>
<blockquote>
<div>[[1, 2], [3, 4]]</div></blockquote>
<p>and target shape = [1, 4], the reshape operator will transform
the tensor X into a 2-D tensor:</p>
<blockquote>
<div>[[1, 2, 3, 4]]</div></blockquote>
<p>One dimension in the target shape can be set -1, representing that its
size is unknown. In this case, the real dimension will be infered from
the original shape of Input(X) and other dimensions in the target shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; The input tensor of reshape operator.
Duplicable: False  Optional: False</li>
<li><strong>shape</strong> (<em>INTS</em>) &#8211; (vector&lt;int&gt;) Target shape of reshape operator.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">The output tensor of reshape operator.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sigmoid">
<h2>sigmoid<a class="headerlink" href="#sigmoid" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">sigmoid</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Sigmoid Activation Operator</p>
<p>$$out = frac{1}{1 + e^{-x}}$$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>x</strong> &#8211; Input of Sigmoid operator
Duplicable: False  Optional: False</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">Output of Sigmoid operator</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="scale">
<h2>scale<a class="headerlink" href="#scale" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">scale</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Scale operator</p>
<p>$$Out = scale*X$$</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; (Tensor) Input tensor of scale operator.
Duplicable: False  Optional: False</li>
<li><strong>scale</strong> (<em>FLOAT</em>) &#8211; (float, default 0)The scaling factor of the scale operator.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(Tensor) Output tensor of scale operator.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="transpose">
<h2>transpose<a class="headerlink" href="#transpose" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">transpose</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Transpose Operator.</p>
<p>The input tensor will be permuted according to the axis values given.
The op functions is similar to how numpy.transpose works in python.</p>
<p>For example:</p>
<blockquote>
<div><div class="highlight-text"><div class="highlight"><pre><span></span>input = numpy.arange(6).reshape((2,3))

the input is:

array([[0, 1, 2],
       [3, 4, 5]])

given axis is:

[1, 0]

output = input.transpose(axis)

then the output is:

array([[0, 3],
       [1, 4],
       [2, 5]])
</pre></div>
</div>
</div></blockquote>
<p>So, given a input tensor of shape(N, C, H, W) and the axis is {0, 2, 3, 1},
the output tensor shape will be (N, H, W, C)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> &#8211; (Tensor)The input tensor, tensors with rank at most 6 are supported
Duplicable: False  Optional: False</li>
<li><strong>axis</strong> (<em>INTS</em>) &#8211; (vector&lt;int&gt;)A list of values, and the size of the list should be the same with the input tensor rank, the tensor will permute the axes according the the values given</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">(Tensor)The output tensor</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sigmoid-cross-entropy-with-logits">
<h2>sigmoid_cross_entropy_with_logits<a class="headerlink" href="#sigmoid-cross-entropy-with-logits" title="永久链接至标题">¶</a></h2>
</div>
<div class="section" id="cast">
<h2>cast<a class="headerlink" href="#cast" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">cast</code><span class="sig-paren">(</span><em>x</em>, <em>dtype</em><span class="sig-paren">)</span></dt>
<dd><p>This function takes in the input with input_dtype
and casts it to the output_dtype as the output.</p>
</dd></dl>

</div>
<div class="section" id="concat">
<h2>concat<a class="headerlink" href="#concat" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">concat</code><span class="sig-paren">(</span><em>input</em>, <em>axis=0</em><span class="sig-paren">)</span></dt>
<dd><p><strong>Concat</strong></p>
<p>This function concatenates the input along the axis mentioned
and returns that as the output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>list</em>) &#8211; List of tensors to be concatenated</li>
<li><strong>axis</strong> (<em>int</em>) &#8211; Integer axis along which the tensors will be concatenated</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">Output variable of the concatenation</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
</dd></dl>

</div>
<div class="section" id="sums">
<h2>sums<a class="headerlink" href="#sums" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">sums</code><span class="sig-paren">(</span><em>input</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p>This function performs the sum operation on the input and returns the
result as the output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>input</strong> (<em>Variable|list</em>) &#8211; The input tensor that has the elements
that need to be summed up.</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><dl class="docutils">
<dt>The tensor type variable that has the sum of input</dt>
<dd>written to it.</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body">Variable</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
</dd></dl>

</div>
<div class="section" id="linear-chain-crf">
<h2>linear_chain_crf<a class="headerlink" href="#linear-chain-crf" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">linear_chain_crf</code><span class="sig-paren">(</span><em>input</em>, <em>label</em>, <em>param_attr=None</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</div>
<div class="section" id="assign">
<h2>assign<a class="headerlink" href="#assign" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">embedding</code><span class="sig-paren">(</span><em>input</em>, <em>size</em>, <em>is_sparse=False</em>, <em>param_attr=None</em>, <em>dtype='float32'</em><span class="sig-paren">)</span></dt>
<dd><p><strong>Embedding Layer</strong></p>
<p>This layer is used to lookup a vector of IDs, provided by <em>input</em>, in a lookup table.
The result of this lookup is the embedding of each ID in the <em>input</em>.</p>
<p>All the input variables are passed in as local variables to the LayerHelper
constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>Variable</em>) &#8211; Input to the function</li>
<li><strong>size</strong> (<em>tuple|list|None</em>) &#8211; Shape of the look up table parameter</li>
<li><strong>is_sparse</strong> (<em>bool</em>) &#8211; Boolean flag that specifying whether the input is sparse</li>
<li><strong>param_attr</strong> (<em>ParamAttr</em>) &#8211; Parameters for this layer</li>
<li><strong>dtype</strong> (<em>np.dtype|core.DataType|str</em>) &#8211; The type of data : float32, float_16, int etc</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The tensor variable storing the embeddings of the                   supplied inputs.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">dict_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">ids</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ids&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="n">fc</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">embedding</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="n">dict_size</span><span class="p">,</span> <span class="mi">16</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="split-lod-tensor">
<h2>split_lod_tensor<a class="headerlink" href="#split-lod-tensor" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">split_lod_tensor</code><span class="sig-paren">(</span><em>input</em>, <em>mask</em>, <em>level=0</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</div>
<div class="section" id="merge-lod-tensor">
<h2>merge_lod_tensor<a class="headerlink" href="#merge-lod-tensor" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">merge_lod_tensor</code><span class="sig-paren">(</span><em>in_true</em>, <em>in_false</em>, <em>x</em>, <em>mask</em>, <em>level=0</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</div>
<div class="section" id="cos-sim">
<h2>cos_sim<a class="headerlink" href="#cos-sim" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">cos_sim</code><span class="sig-paren">(</span><em>X</em>, <em>Y</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>This function performs the cosine similarity between two tensors
X and Y and returns that as the output.</p>
</dd></dl>

</div>
<div class="section" id="cross-entropy">
<h2>cross_entropy<a class="headerlink" href="#cross-entropy" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">cross_entropy</code><span class="sig-paren">(</span><em>input</em>, <em>label</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p><strong>Cross Entropy Layer</strong></p>
<p>This layer computes the cross entropy between <cite>input</cite> and <cite>label</cite>. It supports
both standard cross-entropy and soft-label cross-entropy loss computation.</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>One-hot cross-entropy:</dt>
<dd><p class="first"><cite>soft_label = False</cite>, <cite>Label[i, 0]</cite> indicates the class index for sample i:</p>
<div class="last math">
\[Y[i] = -\log(X[i, Label[i]])\]</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Soft-label cross-entropy:</dt>
<dd><p class="first"><cite>soft_label = True</cite>, <cite>Label[i, j]</cite> indicates the soft label of class j
for sample i:</p>
<div class="last math">
\[Y[i] = \sum_j{-Label[i, j] * log(X[i, j])}\]</div>
</dd>
</dl>
<p>Please make sure that in this case the summation of each row of <cite>label</cite>
equals one.</p>
</li>
<li><dl class="first docutils">
<dt>One-hot cross-entropy with vecterized <cite>label</cite>:</dt>
<dd><p class="first last">As a special case of 2), when each row of &#8216;label&#8217; has only one
non-zero element which is equal to 1, soft-label cross-entropy degenerates
to a one-hot cross-entropy with one-hot label representation.</p>
</dd>
</dl>
</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>Variable|list</em>) &#8211; a 2-D tensor with shape [N x D], where N is the
batch size and D is the number of classes. This input is a probability
computed by the previous operator, which is almost always the result
of a softmax operator.</li>
<li><strong>label</strong> (<em>Variable|list</em>) &#8211; the ground truth which is a 2-D tensor. When
<cite>soft_label</cite> is set to <cite>False</cite>, <cite>label</cite> is a tensor&lt;int64&gt; with shape
[N x 1]. When <cite>soft_label</cite> is set to <cite>True</cite>, <cite>label</cite> is a
tensor&lt;float/double&gt; with shape [N x D].</li>
<li><strong>soft_label</strong> (bool, via <cite>**kwargs</cite>) &#8211; a flag indicating whether to interpretate
the given labels as soft labels, default <cite>False</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">A 2-D tensor with shape [N x 1], the cross entropy loss.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><cite>ValueError</cite> &#8211; 1) the 1st dimension of <cite>input</cite> and <cite>label</cite> are not equal; 2) when <cite>soft_label == True</cite>, and the 2nd dimension of <cite>input</cite> and <cite>label</cite> are not                equal; 3) when <cite>soft_label == False</cite>, and the 2nd dimension of <cite>label</cite> is not 1.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">predict</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">net</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">classdim</span><span class="p">,</span> <span class="n">act</span><span class="o">=</span><span class="s1">&#39;softmax&#39;</span><span class="p">)</span>
<span class="n">cost</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">cross_entropy</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">predict</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="square-error-cost">
<h2>square_error_cost<a class="headerlink" href="#square-error-cost" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">square_error_cost</code><span class="sig-paren">(</span><em>input</em>, <em>label</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>This functions returns the squared error cost using the input and label.
The output is appending the op to do the above.</p>
</dd></dl>

</div>
<div class="section" id="accuracy">
<h2>accuracy<a class="headerlink" href="#accuracy" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">accuracy</code><span class="sig-paren">(</span><em>input</em>, <em>label</em>, <em>k=1</em>, <em>correct=None</em>, <em>total=None</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>This function computes the accuracy using the input and label.
The output is the top_k inputs and their indices.</p>
</dd></dl>

</div>
<div class="section" id="sequence-conv">
<h2>sequence_conv<a class="headerlink" href="#sequence-conv" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">sequence_conv</code><span class="sig-paren">(</span><em>input</em>, <em>num_filters</em>, <em>filter_size=3</em>, <em>filter_stride=1</em>, <em>padding=None</em>, <em>bias_attr=None</em>, <em>param_attr=None</em>, <em>act=None</em><span class="sig-paren">)</span></dt>
<dd><p>This function creates the op for sequence_conv, using the inputs and
other convolutional configurations for the filters and stride as given
in the input parameters to the function.</p>
</dd></dl>

</div>
<div class="section" id="conv2d">
<h2>conv2d<a class="headerlink" href="#conv2d" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">conv2d</code><span class="sig-paren">(</span><em>input</em>, <em>num_filters</em>, <em>filter_size</em>, <em>stride=None</em>, <em>padding=None</em>, <em>groups=None</em>, <em>param_attr=None</em>, <em>bias_attr=None</em>, <em>act=None</em><span class="sig-paren">)</span></dt>
<dd><p><strong>Convlution2D Layer</strong></p>
<p>The convolution2D layer calculates the output based on the input, filter
and strides, paddings, dilations, groups parameters. Input(Input) and Output(Output)
are in NCHW format. Where N is batch size, C is the number of channels, H is the height
of the feature, and W is the width of the feature.
The details of convolution layer, please refer UFLDL&#8217;s <a class="reference external" href="http://ufldl.stanford.edu/tutorial/supervised/FeatureExtractionUsingConvolution/">convolution,</a> .
If bias attribution and activation type are provided, bias is added to the output of the convolution,
and the corresponding activation function is applied to the final result.
For each input <span class="math">\(X\)</span>, the equation is:</p>
<div class="math">
\[Out = \sigma (W \ast X + b)\]</div>
<p>In the above equation:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(X\)</span>: Input value, a tensor with NCHW format.</li>
<li><span class="math">\(W\)</span>: Filter value, a tensor with MCHW format.</li>
<li><span class="math">\(\ast\)</span>: Convolution operation.</li>
<li><span class="math">\(b\)</span>: Bias value, a 2-D tensor with shape [M, 1].</li>
<li><span class="math">\(\sigma\)</span>: Activation function.</li>
<li><span class="math">\(Out\)</span>: Output value, the shape of <span class="math">\(Out\)</span> and <span class="math">\(X\)</span> may be different.</li>
</ul>
</div></blockquote>
<p class="rubric">Example</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><p class="first">Input shape: $(N, C_{in}, H_{in}, W_{in})$</p>
<p class="last">Filter shape: $(C_{out}, C_{in}, H_f, W_f)$</p>
</dd>
<dt>Output:</dt>
<dd>Output shape: $(N, C_{out}, H_{out}, W_{out})$</dd>
</dl>
<p>Where</p>
<div class="math">
\[\begin{split}H_{out}&amp;= \frac{(H_{in} + 2 * paddings[0] - (dilations[0] * (H_f - 1) + 1))}{strides[0]} + 1 \\
W_{out}&amp;= \frac{(W_{in} + 2 * paddings[1] - (dilations[1] * (W_f - 1) + 1))}{strides[1]} + 1\end{split}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>Variable</em>) &#8211; The input image with [N, C, H, W] format.</li>
<li><strong>num_filters</strong> (<em>int</em>) &#8211; The number of filter. It is as same as the output
image channel.</li>
<li><strong>filter_size</strong> (<em>int|tuple|None</em>) &#8211; The filter size. If filter_size is a tuple,
it must contain two integers, (filter_size_H, filter_size_W).
Otherwise, the filter will be a square.</li>
<li><strong>stride</strong> (<em>int|tuple</em>) &#8211; The stride size. If stride is a tuple, it must
contain two integers, (stride_H, stride_W). Otherwise, the
stride_H = stride_W = stride. Default: stride = 1.</li>
<li><strong>padding</strong> (<em>int|tuple</em>) &#8211; The padding size. If padding is a tuple, it must
contain two integers, (padding_H, padding_W). Otherwise, the
padding_H = padding_W = padding. Default: padding = 0.</li>
<li><strong>groups</strong> (<em>int</em>) &#8211; The groups number of the Conv2d Layer. According to grouped
convolution in Alex Krizhevsky&#8217;s Deep CNN paper: when group=2,
the first half of the filters is only connected to the first half
of the input channels, while the second half of the filters is only
connected to the second half of the input channels. Default: groups=1</li>
<li><strong>param_attr</strong> (<em>ParamAttr</em>) &#8211; The parameters to the Conv2d Layer. Default: None</li>
<li><strong>bias_attr</strong> (<em>ParamAttr</em>) &#8211; Bias parameter for the Conv2d layer. Default: None</li>
<li><strong>act</strong> (<em>str</em>) &#8211; Activation type. Default: None</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The tensor variable storing the convolution and                   non-linearity activation result.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first">Variable</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> &#8211; If the shapes of input, filter_size, stride, padding and groups mismatch.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="n">conv2d</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">num_filters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">filter_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">act</span><span class="o">=</span><span class="s2">&quot;relu&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sequence-pool">
<h2>sequence_pool<a class="headerlink" href="#sequence-pool" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">sequence_pool</code><span class="sig-paren">(</span><em>input</em>, <em>pool_type</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>This function add the operator for sequence pooling.
It pools features of all time-steps of each instance, and is applied
on top of the input using pool_type mentioned in the parameters.</p>
<p>It supports four pool_type:</p>
<ul class="simple">
<li>average: <span class="math">\(Out[i] = \frac{\sum_i X_i}{N}\)</span></li>
<li>sum:     <span class="math">\(Out[i] = \sum_jX_{ij}\)</span></li>
<li>sqrt:    <span class="math">\(Out[i] = \frac{\sum_jX_{ij}}{\sqrt{len(X_i)}}\)</span></li>
<li>max:     <span class="math">\(Out[i] = max(X_i)\)</span></li>
</ul>
<div class="highlight-text"><div class="highlight"><pre><span></span>x is a 1-level LoDTensor:
  x.lod = [[0, 2, 5, 7]]
  x.data = [1, 3, 2, 4, 6, 5, 1]
  x.dims = [7, 1]

then output is a Tensor:
  out.dim = [3, 1]
  with condition len(x.lod[-1]) - 1 == out.dims[0]

for different pool_type:
  average: out.data = [2, 4, 3], where 2=(1+3)/2, 4=(2+4+6)/3, 3=(5+1)/2
  sum    : out.data = [4, 12, 6], where 4=1+3, 12=2+4+6, 6=5+1
  sqrt   : out.data = [2.82, 6.93, 4.24], where 2.82=(1+3)/sqrt(2),
             6.93=(2+4+6)/sqrt(3), 4.24=(5+1)/sqrt(2)
  max    : out.data = [3, 6, 5], where 3=max(1,3), 6=max(2,4,6), 5=max(5,1)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>variable</em>) &#8211; The input variable which is a LoDTensor.</li>
<li><strong>pool_type</strong> (<em>string</em>) &#8211; The pooling type of sequence_pool.
It supports average, sum, sqrt and max.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first last">The sequence pooling variable which is a Tensor.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                 <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">lod_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">avg_x</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">sequence_pool</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">pool_type</span><span class="o">=</span><span class="s1">&#39;average&#39;</span><span class="p">)</span>
<span class="n">sum_x</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">sequence_pool</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">pool_type</span><span class="o">=</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>
<span class="n">sqrt_x</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">sequence_pool</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">pool_type</span><span class="o">=</span><span class="s1">&#39;sqrt&#39;</span><span class="p">)</span>
<span class="n">max_x</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">sequence_pool</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">pool_type</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sequence-first-step">
<h2>sequence_first_step<a class="headerlink" href="#sequence-first-step" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">sequence_first_step</code><span class="sig-paren">(</span><em>input</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>This funciton get the first step of sequence.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>x is a 1-level LoDTensor:
  x.lod = [[0, 2, 5, 7]]
  x.data = [1, 3, 2, 4, 6, 5, 1]
  x.dims = [7, 1]

then output is a Tensor:
  out.dim = [3, 1]
  with condition len(x.lod[-1]) - 1 == out.dims[0]
  out.data = [1, 2, 5], where 1=first(1,3), 2=first(2,4,6), 5=first(5,1)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>input</strong> (<em>variable</em>) &#8211; The input variable which is a LoDTensor.</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">The sequence&#8217;s first step variable which is a Tensor.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                 <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">lod_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">x_first_step</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">sequence_first_step</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sequence-last-step">
<h2>sequence_last_step<a class="headerlink" href="#sequence-last-step" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">sequence_last_step</code><span class="sig-paren">(</span><em>input</em>, <em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>This funciton get the last step of sequence.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>x is a 1-level LoDTensor:
  x.lod = [[0, 2, 5, 7]]
  x.data = [1, 3, 2, 4, 6, 5, 1]
  x.dims = [7, 1]

then output is a Tensor:
  out.dim = [3, 1]
  with condition len(x.lod[-1]) - 1 == out.dims[0]
  out.data = [3, 6, 1], where 3=last(1,3), 6=last(2,4,6), 1=last(5,1)
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>input</strong> (<em>variable</em>) &#8211; The input variable which is a LoDTensor.</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">The sequence&#8217;s last step variable which is a Tensor.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                 <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">lod_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">x_last_step</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">sequence_last_step</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="pool2d">
<h2>pool2d<a class="headerlink" href="#pool2d" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">pool2d</code><span class="sig-paren">(</span><em>input</em>, <em>pool_size</em>, <em>pool_type</em>, <em>pool_stride=None</em>, <em>pool_padding=None</em>, <em>global_pooling=False</em><span class="sig-paren">)</span></dt>
<dd><p>This function adds the operator for pooling in 2 dimensions, using the
pooling configurations mentioned in input parameters.</p>
</dd></dl>

</div>
<div class="section" id="batch-norm">
<h2>batch_norm<a class="headerlink" href="#batch-norm" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">batch_norm</code><span class="sig-paren">(</span><em>input</em>, <em>act=None</em>, <em>is_test=False</em>, <em>momentum=0.9</em>, <em>epsilon=1e-05</em>, <em>param_attr=None</em>, <em>bias_attr=None</em>, <em>data_layout='NCHW'</em><span class="sig-paren">)</span></dt>
<dd><p>This function helps create an operator to implement
the BatchNorm layer using the configurations from the input parameters.</p>
</dd></dl>

</div>
<div class="section" id="beam-search-decode">
<h2>beam_search_decode<a class="headerlink" href="#beam-search-decode" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">beam_search_decode</code><span class="sig-paren">(</span><em>ids</em>, <em>scores</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</div>
<div class="section" id="lod-rank-table">
<h2>lod_rank_table<a class="headerlink" href="#lod-rank-table" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">lod_rank_table</code><span class="sig-paren">(</span><em>x</em>, <em>level=0</em><span class="sig-paren">)</span></dt>
<dd><p>LoD Rank Table Operator. Given an input variable <strong>x</strong> and a level number
of LoD, this layer creates a LodRankTable object. A LoDRankTable object
contains a list of bi-element tuples. Each tuple consists of an index and
a length, both of which are int type. Reffering to specified level of LoD,
the index is the sequence index number and the length representes the
sequence length. Please note that the list is ranked in descending order by
the length. The following is an example:</p>
<blockquote>
<div><div class="highlight-text"><div class="highlight"><pre><span></span>x is a LoDTensor:
    x.lod = [[0,                2, 3],
             [0,             5, 6, 7]]
    x.data = [a, b, c, d, e, f, g]

1. set level to 0:
    Create lod rank table:
        lod_rank_table_obj = lod_rank_table(x, level=0)

    Get:
        lod_rank_table_obj.items() = [(0, 2), (1, 1)]

2. set level to 1:
    Create lod rank table:
        lod_rank_table_obj = lod_rank_table(x, level=1)

    Get:
        lod_rank_table_obj.items() = [(0, 5), (1, 1), (2, 1)]
</pre></div>
</div>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>Variable</em>) &#8211; Input variable, a LoDTensor based which to create the lod
rank table.</li>
<li><strong>level</strong> (<em>int</em>) &#8211; Specify the LoD level, on which to create the lod rank
table.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The created LoDRankTable object.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">lod_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">lod_rank_table</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="max-sequence-len">
<h2>max_sequence_len<a class="headerlink" href="#max-sequence-len" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">max_sequence_len</code><span class="sig-paren">(</span><em>rank_table</em><span class="sig-paren">)</span></dt>
<dd><p>This function creates an operator to calculate the length of
max seqence through input rank_table(should be a lod_rank_table)</p>
</dd></dl>

</div>
<div class="section" id="topk">
<h2>topk<a class="headerlink" href="#topk" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">topk</code><span class="sig-paren">(</span><em>input</em>, <em>k</em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

</div>
<div class="section" id="lod-tensor-to-array">
<h2>lod_tensor_to_array<a class="headerlink" href="#lod-tensor-to-array" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">lod_tensor_to_array</code><span class="sig-paren">(</span><em>x</em>, <em>table</em><span class="sig-paren">)</span></dt>
<dd><dl class="docutils">
<dt>This function performs the operation that converts an LOD_Tensor to</dt>
<dd>an array.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>Variable|list</em>) &#8211; The tensor that needs to be converted to an array.</li>
<li><strong>table</strong> (<em>ParamAttr|list</em>) &#8211; The variable that stores the level of lod
which is ordered by sequence length in
descending order.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>The variable of type array that has been converted from a</dt>
<dd><p class="first last">tensor.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">lod_rank_table</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">array</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">lod_tensor_to_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="array-to-lod-tensor">
<h2>array_to_lod_tensor<a class="headerlink" href="#array-to-lod-tensor" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">array_to_lod_tensor</code><span class="sig-paren">(</span><em>x</em>, <em>table</em><span class="sig-paren">)</span></dt>
<dd><dl class="docutils">
<dt>This function performs the operations that converts an array to</dt>
<dd>an LOD_Tensor.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>Variable|list</em>) &#8211; The array that needs to be converted to a tensor.</li>
<li><strong>table</strong> (<em>ParamAttr|list</em>) &#8211; The variable that stores the level of lod
which is ordered by sequence length in
descending order.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>The variable of type tensor that has been converted</dt>
<dd><p class="first last">from an array.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">lod_rank_table</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">array</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">lod_tensor_to_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>
<span class="n">lod_tensor</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">array_to_lod_tensor</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="fill-constant">
<h2>fill_constant<a class="headerlink" href="#fill-constant" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">fill_constant</code><span class="sig-paren">(</span><em>shape</em>, <em>dtype</em>, <em>value</em>, <em>out=None</em><span class="sig-paren">)</span></dt>
<dd><p><strong>fill_constant</strong></p>
<p>This function creates a tensor of specified <em>shape</em> and
<em>dtype</em>, and initializes this with a constant supplied in <em>value</em>.</p>
<p>It also sets <em>stop_gradient</em> to True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>shape</strong> (<em>tuple|list|None</em>) &#8211; Shape of output tensor</li>
<li><strong>dtype</strong> (<em>np.dtype|core.DataType|str</em>) &#8211; Data type of output tensor</li>
<li><strong>value</strong> (<em>float</em>) &#8211; Constant value to initialize the output tensor</li>
<li><strong>out</strong> (<em>Variable</em>) &#8211; Output Variable to initialize</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The tensor variable storing the output</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">fill_constant</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="fill-constant-batch-size-like">
<h2>fill_constant_batch_size_like<a class="headerlink" href="#fill-constant-batch-size-like" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">fill_constant_batch_size_like</code><span class="sig-paren">(</span><em>input</em>, <em>shape</em>, <em>dtype</em>, <em>value</em>, <em>input_dim_idx=0</em>, <em>output_dim_idx=0</em><span class="sig-paren">)</span></dt>
<dd><p><strong>fill_constant_batch_size_like</strong></p>
<p>This function creates a tensor of specified <em>shape</em>, <em>dtype</em> and batch size,
and initializes this with a constant supplied in <em>value</em>. The batch size is
obtained from the <cite>input</cite> tensor.</p>
<p>It also sets <em>stop_gradient</em> to True.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>Variable</em>) &#8211; Tensor whose dimensions will be used to get batch size</li>
<li><strong>shape</strong> (<em>tuple|list|None</em>) &#8211; Shape of output tensor</li>
<li><strong>dtype</strong> (<em>np.dtype|core.DataType|str</em>) &#8211; Data type of output tensor</li>
<li><strong>value</strong> (<em>float</em>) &#8211; Constant value to initialize the output tensor</li>
<li><strong>input_dim_idx</strong> (<em>int</em>) &#8211; Index of input&#8217;s batch size dimension</li>
<li><strong>output_dim_idx</strong> (<em>int</em>) &#8211; Index of output&#8217;s batch size dimension</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The tensor variable storing the output</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">fill_constant</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="ones">
<h2>ones<a class="headerlink" href="#ones" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">ones</code><span class="sig-paren">(</span><em>shape</em>, <em>dtype</em><span class="sig-paren">)</span></dt>
<dd><p>This function performs the same function as fill_constant() declared above
with the constant value being 1.0.</p>
</dd></dl>

</div>
<div class="section" id="zeros">
<h2>zeros<a class="headerlink" href="#zeros" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">zeros</code><span class="sig-paren">(</span><em>shape</em>, <em>dtype</em><span class="sig-paren">)</span></dt>
<dd><p>This function performs the same function as fill_constant() declared above
with the constant value being 0.0.</p>
</dd></dl>

</div>
<div class="section" id="increment">
<h2>increment<a class="headerlink" href="#increment" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">increment</code><span class="sig-paren">(</span><em>x</em>, <em>value=1.0</em>, <em>in_place=True</em><span class="sig-paren">)</span></dt>
<dd><p>This function performs an operation that increments each value in the
input <span class="math">\(x\)</span> by an amount: <span class="math">\(value\)</span> as mentioned in the input
parameter. This operation is performed in-place by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>Variable|list</em>) &#8211; The tensor that has the input values.</li>
<li><strong>value</strong> (<em>float</em>) &#8211; The amount by which the values should be incremented.</li>
<li><strong>in_place</strong> (<em>bool</em>) &#8211; If the increment should be performed in-place.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>The tensor variable storing the transformation of</dt>
<dd><p class="first last">element-wise increment of each value in the input.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="array-write">
<h2>array_write<a class="headerlink" href="#array-write" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">array_write</code><span class="sig-paren">(</span><em>x</em>, <em>i</em>, <em>array=None</em><span class="sig-paren">)</span></dt>
<dd><p>This function performs the operation to write the data out as an
LOD_TENSOR_ARRAY.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>Variable|list</em>) &#8211; The input tensor from which the data will be read.</li>
<li><strong>i</strong> (<em>Variable|list</em>) &#8211; The subscript index in tensor array, that points the
place from which data will be read.</li>
<li><strong>array</strong> (<em>Variable|list</em>) &#8211; The data can be read into this variable if
this is assigned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The tensor type variable that has the data written to it.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
</dd></dl>

</div>
<div class="section" id="create-array">
<h2>create_array<a class="headerlink" href="#create-array" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">create_array</code><span class="sig-paren">(</span><em>dtype</em><span class="sig-paren">)</span></dt>
<dd><p>This function creates an array of type <span class="math">\(LOD_TENSOR_ARRAY\)</span> using the
LayerHelper.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>dtype</strong> (<em>int|float</em>) &#8211; The data type of the elements in the array.</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">The tensor variable storing the elements of data type.</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body">Variable</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">create_array</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="less-than">
<h2>less_than<a class="headerlink" href="#less-than" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">less_than</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>cond=None</em>, <em>**ignored</em><span class="sig-paren">)</span></dt>
<dd><p><strong>Less than</strong></p>
<p>This layer returns the truth value of <span class="math">\(x &lt; y\)</span> elementwise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>Variable</em>) &#8211; First operand of <em>less_than</em></li>
<li><strong>y</strong> (<em>Variable</em>) &#8211; Second operand of <em>less_than</em></li>
<li><strong>cond</strong> (<em>Variable|None</em>) &#8211; Optional output variable to store the result of <em>less_than</em></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The tensor variable storing the output of <em>less_than</em>.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">less</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">less_than</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="array-read">
<h2>array_read<a class="headerlink" href="#array-read" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">array_read</code><span class="sig-paren">(</span><em>array</em>, <em>i</em><span class="sig-paren">)</span></dt>
<dd><p>This function performs the operation to read the data in as an
LOD_TENSOR_ARRAY.
:param array: The input tensor that will be written to an array.
:type array: Variable|list
:param i: The subscript index in tensor array, that points the</p>
<blockquote>
<div>place where data will be written to.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">返回:</th><td class="field-body">The tensor type variable that has the data written to it.</td>
</tr>
<tr class="field-even field"><th class="field-name">返回类型:</th><td class="field-body">Variable</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
</dd></dl>

</div>
<div class="section" id="shrink-memory">
<h2>shrink_memory<a class="headerlink" href="#shrink-memory" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">shrink_memory</code><span class="sig-paren">(</span><em>x</em>, <em>i</em>, <em>table</em><span class="sig-paren">)</span></dt>
<dd><p>This function creates an operator to shrink_rnn_memory using the RankTable
as mentioned in the input parameter.</p>
</dd></dl>

</div>
<div class="section" id="array-length">
<h2>array_length<a class="headerlink" href="#array-length" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">array_length</code><span class="sig-paren">(</span><em>array</em><span class="sig-paren">)</span></dt>
<dd><p>This function performs the operation to find the length of the input
LOD_TENSOR_ARRAY.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>array</strong> (<em>LOD_TENSOR_ARRAY</em>) &#8211; The input array that will be used
to compute the length.</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">The length of the input LoDTensorArray.</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body">Variable</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
</dd></dl>

</div>
<div class="section" id="conv2d-transpose">
<h2>conv2d_transpose<a class="headerlink" href="#conv2d-transpose" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">conv2d_transpose</code><span class="sig-paren">(</span><em>input</em>, <em>num_filters</em>, <em>output_size=None</em>, <em>filter_size=None</em>, <em>padding=None</em>, <em>stride=None</em>, <em>dilation=None</em>, <em>param_attr=None</em><span class="sig-paren">)</span></dt>
<dd><p>The transpose of conv2d layer.</p>
<p>This layer is also known as deconvolution layer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>Variable</em>) &#8211; The input image with [N, C, H, W] format.</li>
<li><strong>num_filters</strong> (<em>int</em>) &#8211; The number of filter. It is as same as the output
image channel.</li>
<li><strong>output_size</strong> (<em>int|tuple|None</em>) &#8211; The output image size. If output size is a
tuple, it must contain two integers, (image_H, image_W). This
parameter only works when filter_size is None.</li>
<li><strong>filter_size</strong> (<em>int|tuple|None</em>) &#8211; The filter size. If filter_size is a tuple,
it must contain two integers, (filter_size_H, filter_size_W).
Otherwise, the filter will be a square.  None if use output size to
calculate filter_size</li>
<li><strong>padding</strong> (<em>int|tuple</em>) &#8211; The padding size. If padding is a tuple, it must
contain two integers, (padding_H, padding_W). Otherwise, the
padding_H = padding_W = padding.</li>
<li><strong>stride</strong> (<em>int|tuple</em>) &#8211; The stride size. If stride is a tuple, it must
contain two integers, (stride_H, stride_W). Otherwise, the
stride_H = stride_W = stride.</li>
<li><strong>dilation</strong> (<em>int|tuple</em>) &#8211; The dilation size. If dilation is a tuple, it must
contain two integers, (dilation_H, dilation_W). Otherwise, the
dilation_H = dilation_W = dilation.</li>
<li><strong>param_attr</strong> &#8211; Parameter Attribute.</li>
<li><strong>main_program</strong> (<em>Program</em>) &#8211; the main program</li>
<li><strong>startup_program</strong> (<em>Program</em>) &#8211; the startup program</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">Output image.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sequence-expand">
<h2>sequence_expand<a class="headerlink" href="#sequence-expand" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">sequence_expand</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span></dt>
<dd><p>Sequence Expand Layer. This layer will expand the input variable <strong>x</strong>
according to LoD information of <strong>y</strong>. And the following examples will
explain how sequence_expand works:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>* Case 1
    x is a LoDTensor:
        x.lod = [[0,       2, 3],
                 [0, 1,    3, 4]]
        x.data = [a, b, c, d]
        x.dims = [4, 1]

    y is a LoDTensor:
        y.lod = [[0,    2,    4],
                 [0, 3, 6, 7, 8]]

    with condition len(y.lod[-1]) - 1 == x.dims[0]

    then output is a 2-level LoDTensor:
        out.lod = [[0,                2,    4],
                   [0,       3,       6, 7, 8]]
        out.data = [a, a, a, b, b, b, c, d]
        out.dims = [8, 1]

* Case 2
    x is a Tensor:
        x.data = [a, b, c]
        x.dims = [3, 1]

    y is a LoDTensor:
        y.lod = [[0, 2, 3, 6]]

    with condition len(y.lod[-1]) - 1 == x.dims[0]

    then output is a 1-level LoDTensor:
        out.lod = [[0,    2, 3,      6]]
        out.data = [a, a, b, c, c, c]
        out.dims = [6, 1]
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>Variable</em>) &#8211; The input variable which is a Tensor or LoDTensor.</li>
<li><strong>y</strong> (<em>Variable</em>) &#8211; The input variable which is a LoDTensor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The expanded variable which is a LoDTensor.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">data</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
                 <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">,</span> <span class="n">lod_level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">sequence_expand</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="lstm-unit">
<h2>lstm_unit<a class="headerlink" href="#lstm-unit" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">lstm_unit</code><span class="sig-paren">(</span><em>x_t</em>, <em>hidden_t_prev</em>, <em>cell_t_prev</em>, <em>forget_bias=0.0</em>, <em>param_attr=None</em>, <em>bias_attr=None</em><span class="sig-paren">)</span></dt>
<dd><p>Lstm unit layer. The equation of a lstm step is:</p>
<blockquote>
<div><div class="math">
\[ \begin{align}\begin{aligned}i_t &amp; = \sigma(W_{x_i}x_{t} + W_{h_i}h_{t-1} + W_{c_i}c_{t-1} + b_i)\\f_t &amp; = \sigma(W_{x_f}x_{t} + W_{h_f}h_{t-1} + W_{c_f}c_{t-1} + b_f)\\c_t &amp; = f_tc_{t-1} + i_t tanh (W_{x_c}x_t+W_{h_c}h_{t-1} + b_c)\\o_t &amp; = \sigma(W_{x_o}x_{t} + W_{h_o}h_{t-1} + W_{c_o}c_t + b_o)\\h_t &amp; = o_t tanh(c_t)\end{aligned}\end{align} \]</div>
</div></blockquote>
<p>The inputs of lstm unit includes <span class="math">\(x_t\)</span>, <span class="math">\(h_{t-1}\)</span> and
<span class="math">\(c_{t-1}\)</span>. The implementation separates the linear transformation
and non-linear transformation apart. Here, we take <span class="math">\(i_t\)</span> as an
example. The linear transformation is applied by calling a <cite>fc</cite> layer and
the equation is:</p>
<blockquote>
<div><div class="math">
\[L_{i_t} = W_{x_i}x_{t} + W_{h_i}h_{t-1} + W_{c_i}c_{t-1} + b_i\]</div>
</div></blockquote>
<p>The non-linear transformation is applied by calling <cite>lstm_unit_op</cite> and the
equation is:</p>
<blockquote>
<div><div class="math">
\[i_t = \sigma(L_{i_t})\]</div>
</div></blockquote>
<p>This layer has two outputs including <span class="math">\(h_t\)</span> and <span class="math">\(o_t\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>x_t</strong> (<em>Variable</em>) &#8211; The input value of current step.</li>
<li><strong>hidden_t_prev</strong> (<em>Variable</em>) &#8211; The hidden value of lstm unit.</li>
<li><strong>cell_t_prev</strong> (<em>Variable</em>) &#8211; The cell value of lstm unit.</li>
<li><strong>forget_bias</strong> (<em>float</em>) &#8211; The forget bias of lstm unit.</li>
<li><strong>param_attr</strong> (<em>ParamAttr</em>) &#8211; The attributes of parameter weights, used to set
initializer, name etc.</li>
<li><strong>bias_attr</strong> (<em>ParamAttr</em>) &#8211; The attributes of bias weights, if not False,
bias weights will be created and be set to default value.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The hidden value and cell value of lstm unit.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first">tuple</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> &#8211; The ranks of <strong>x_t</strong>, <strong>hidden_t_prev</strong> and <strong>cell_t_prev</strong>                not be 2 or the 1st dimensions of <strong>x_t</strong>, <strong>hidden_t_prev</strong>                 and <strong>cell_t_prev</strong> not be the same.</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">x_t</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">x_t_data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">prev_hidden</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">prev_hidden_data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">prev_cell</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">prev_cell_data</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="n">hidden_value</span><span class="p">,</span> <span class="n">cell_value</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">lstm_unit</span><span class="p">(</span><span class="n">x_t</span><span class="o">=</span><span class="n">x_t</span><span class="p">,</span>
                                       <span class="n">hidden_t_prev</span><span class="o">=</span><span class="n">prev_hidden</span><span class="p">,</span>
                                       <span class="n">cell_t_prev</span><span class="o">=</span><span class="n">prev_cell</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sequence-softmax">
<h2>sequence_softmax<a class="headerlink" href="#sequence-softmax" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">sequence_softmax</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span></dt>
<dd><p>Sequence Softmax Operator.</p>
<p>SequenceSoftmaxOp computes the softmax activation among all time-steps for each
sequence. The dimension of each time-step should be 1. Thus, the shape of
input Tensor can be either [N, 1] or [N], where N is the sum of the length
of all sequences.</p>
<p>The algorithm works as follows:</p>
<blockquote>
<div>for i-th sequence in a mini-batch:</div></blockquote>
<p>$$
Out(X[lod[i]:lod[i+1]], :) = frac{exp(X[lod[i]:lod[i+1], :])} {sum(exp(X[lod[i]:lod[i+1], :]))}
$$</p>
<p>For example, for a mini-batch of 3 sequences with variable-length,
each containing 2, 3, 2 time-steps, the lod of which is [0, 2, 5, 7],
then softmax will be computed among X[0:2, :], X[2:5, :], X[5:7, :]
and N turns out to be 7.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>x</strong> &#8211; (LoDTensor) 1-D or 2-D input LoDTensor with the 2-nd dimension of length 1.
Duplicable: False  Optional: False</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body">(LoDTensor) 1-D or 2-D output LoDTensor with the 2-nd dimension of length 1.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="reduce-sum">
<h2>reduce_sum<a class="headerlink" href="#reduce-sum" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">reduce_sum</code><span class="sig-paren">(</span><em>input</em>, <em>dim=None</em>, <em>keep_dim=False</em><span class="sig-paren">)</span></dt>
<dd><p>Computes the sum of tensor elements over the given dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>Variable</em>) &#8211; The input variable which is a Tensor or LoDTensor.</li>
<li><strong>dim</strong> (<em>int|None</em>) &#8211; The dimension along which the sum is performed. If
<code class="xref py py-attr docutils literal"><span class="pre">None</span></code>, sum all elements of <code class="xref py py-attr docutils literal"><span class="pre">input</span></code> and return a
Tensor variable with a single element, otherwise must be in the
range <span class="math">\([-rank(input), rank(input))\)</span>. If <span class="math">\(dim &lt; 0\)</span>,
the dimension to reduce is <span class="math">\(rank + dim\)</span>.</li>
<li><strong>keep_dim</strong> (<em>bool</em>) &#8211; Whether to reserve the reduced dimension in the
output Tensor. The result tensor will have one fewer dimension
than the <code class="xref py py-attr docutils literal"><span class="pre">input</span></code> unless <code class="xref py py-attr docutils literal"><span class="pre">keep_dim</span></code> is true.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The reduced Tensor variable.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># x is a Tensor variable with following elements:</span>
<span class="c1">#    [[0.2, 0.3, 0.5, 0.9]</span>
<span class="c1">#     [0.1, 0.2, 0.6, 0.7]]</span>
<span class="c1"># Each example is followed by the correspending output tensor.</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># [3.5]</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># [0.3, 0.5, 1.1, 1.6]</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># [1.9, 1.6]</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keep_dim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># [[1.9], [1.6]]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="reduce-mean">
<h2>reduce_mean<a class="headerlink" href="#reduce-mean" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">reduce_mean</code><span class="sig-paren">(</span><em>input</em>, <em>dim=None</em>, <em>keep_dim=False</em><span class="sig-paren">)</span></dt>
<dd><p>Computes the mean of tensor elements over the given dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>Variable</em>) &#8211; The input variable which is a Tensor or LoDTensor.</li>
<li><strong>dim</strong> (<em>int|None</em>) &#8211; The dimension along which the mean is computed. If
<code class="xref py py-attr docutils literal"><span class="pre">None</span></code>, compute the mean over all elements of <code class="xref py py-attr docutils literal"><span class="pre">input</span></code>
and return a Tensor variable with a single element, otherwise
must be in the range <span class="math">\([-rank(input), rank(input))\)</span>. If
<span class="math">\(dim &lt; 0\)</span>, the dimension to reduce is <span class="math">\(rank + dim\)</span>.</li>
<li><strong>keep_dim</strong> (<em>bool</em>) &#8211; Whether to reserve the reduced dimension in the
output Tensor. The result tensor will have one fewer dimension
than the <code class="xref py py-attr docutils literal"><span class="pre">input</span></code> unless <code class="xref py py-attr docutils literal"><span class="pre">keep_dim</span></code> is true.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The reduced Tensor variable.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># x is a Tensor variable with following elements:</span>
<span class="c1">#    [[0.2, 0.3, 0.5, 0.9]</span>
<span class="c1">#     [0.1, 0.2, 0.6, 0.7]]</span>
<span class="c1"># Each example is followed by the correspending output tensor.</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># [0.4375]</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># [0.15, 0.25, 0.55, 0.8]</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># [0.475, 0.4]</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keep_dim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># [[0.475], [0.4]]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="reduce-max">
<h2>reduce_max<a class="headerlink" href="#reduce-max" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">reduce_max</code><span class="sig-paren">(</span><em>input</em>, <em>dim=None</em>, <em>keep_dim=False</em><span class="sig-paren">)</span></dt>
<dd><p>Computes the maximum of tensor elements over the given dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>Variable</em>) &#8211; The input variable which is a Tensor or LoDTensor.</li>
<li><strong>dim</strong> (<em>int|None</em>) &#8211; The dimension along which the maximum is computed.
If <code class="xref py py-attr docutils literal"><span class="pre">None</span></code>, compute the maximum over all elements of
<code class="xref py py-attr docutils literal"><span class="pre">input</span></code> and return a Tensor variable with a single element,
otherwise must be in the range <span class="math">\([-rank(input), rank(input))\)</span>.
If <span class="math">\(dim &lt; 0\)</span>, the dimension to reduce is <span class="math">\(rank + dim\)</span>.</li>
<li><strong>keep_dim</strong> (<em>bool</em>) &#8211; Whether to reserve the reduced dimension in the
output Tensor. The result tensor will have one fewer dimension
than the <code class="xref py py-attr docutils literal"><span class="pre">input</span></code> unless <code class="xref py py-attr docutils literal"><span class="pre">keep_dim</span></code> is true.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The reduced Tensor variable.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># x is a Tensor variable with following elements:</span>
<span class="c1">#    [[0.2, 0.3, 0.5, 0.9]</span>
<span class="c1">#     [0.1, 0.2, 0.6, 0.7]]</span>
<span class="c1"># Each example is followed by the correspending output tensor.</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># [0.9]</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># [0.2, 0.3, 0.6, 0.9]</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># [0.9, 0.7]</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keep_dim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># [[0.9], [0.7]]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="reduce-min">
<h2>reduce_min<a class="headerlink" href="#reduce-min" title="永久链接至标题">¶</a></h2>
<dl class="function">
<dt>
<code class="descclassname">paddle.v2.fluid.layers.</code><code class="descname">reduce_min</code><span class="sig-paren">(</span><em>input</em>, <em>dim=None</em>, <em>keep_dim=False</em><span class="sig-paren">)</span></dt>
<dd><p>Computes the minimum of tensor elements over the given dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first simple">
<li><strong>input</strong> (<em>Variable</em>) &#8211; The input variable which is a Tensor or LoDTensor.</li>
<li><strong>dim</strong> (<em>int|None</em>) &#8211; The dimension along which the minimum is computed.
If <code class="xref py py-attr docutils literal"><span class="pre">None</span></code>, compute the minimum over all elements of
<code class="xref py py-attr docutils literal"><span class="pre">input</span></code> and return a Tensor variable with a single element,
otherwise must be in the range <span class="math">\([-rank(input), rank(input))\)</span>.
If <span class="math">\(dim &lt; 0\)</span>, the dimension to reduce is <span class="math">\(rank + dim\)</span>.</li>
<li><strong>keep_dim</strong> (<em>bool</em>) &#8211; Whether to reserve the reduced dimension in the
output Tensor. The result tensor will have one fewer dimension
than the <code class="xref py py-attr docutils literal"><span class="pre">input</span></code> unless <code class="xref py py-attr docutils literal"><span class="pre">keep_dim</span></code> is true.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">返回:</th><td class="field-body"><p class="first">The reduced Tensor variable.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">返回类型:</th><td class="field-body"><p class="first last">Variable</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># x is a Tensor variable with following elements:</span>
<span class="c1">#    [[0.2, 0.3, 0.5, 0.9]</span>
<span class="c1">#     [0.1, 0.2, 0.6, 0.7]]</span>
<span class="c1"># Each example is followed by the correspending output tensor.</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># [0.1]</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># [0.1, 0.2, 0.5, 0.7]</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># [0.2, 0.1]</span>
<span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">reduce_min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keep_dim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># [[0.2], [0.1]]</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="data_feeder.html" class="btn btn-neutral float-right" title="DataFeeder" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../fluid.html" class="btn btn-neutral" title="Fluid" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, PaddlePaddle developers.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ".txt",
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>
       
  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  
  
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/perfect-scrollbar/0.6.14/js/perfect-scrollbar.jquery.min.js"></script>
  <script src="../../../_static/js/paddle_doc_init.js"></script> 

</body>
</html>