

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Design Doc: CSP in PaddlePaddle Fluid &mdash; PaddlePaddle  文档</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
  
        <link rel="index" title="索引"
              href="../genindex.html"/>
        <link rel="search" title="搜索" href="../search.html"/>
    <link rel="top" title="PaddlePaddle  文档" href="../index.html"/> 

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/perfect-scrollbar/0.6.14/css/perfect-scrollbar.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/override.css" type="text/css" />
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?b9a314ab40d04d805655aab1deee08ba";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>

  

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  
  <header class="site-header">
    <div class="site-logo">
      <a href="/"><img src="../_static/images/PP_w.png"></a>
    </div>
    <div class="site-nav-links">
      <div class="site-menu">
        <a class="fork-on-github" href="https://github.com/PaddlePaddle/Paddle" target="_blank"><i class="fa fa-github"></i>Fork me on Github</a>
        <div class="language-switcher dropdown">
          <a type="button" data-toggle="dropdown">
            <span>English</span>
            <i class="fa fa-angle-up"></i>
            <i class="fa fa-angle-down"></i>
          </a>
          <ul class="dropdown-menu">
            <li><a href="/doc_cn">中文</a></li>
            <li><a href="/doc">English</a></li>
          </ul>
        </div>
        <ul class="site-page-links">
          <li><a href="/">Home</a></li>
        </ul>
      </div>
      <div class="doc-module">
        
        <ul>
<li class="toctree-l1"><a class="reference internal" href="../getstarted/index_cn.html">新手入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../howto/index_cn.html">进阶指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index_cn.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index_cn.html">FAQ</a></li>
</ul>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>        
      </div>
    </div>
  </header>
  
  <div class="main-content-wrap">

    
    <nav class="doc-menu-vertical" role="navigation">
        
          
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../getstarted/index_cn.html">新手入门</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getstarted/build_and_install/index_cn.html">安装与编译</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../getstarted/build_and_install/pip_install_cn.html">使用pip安装</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getstarted/build_and_install/docker_install_cn.html">使用Docker安装运行</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/dev/build_cn.html">用Docker编译和测试PaddlePaddle</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getstarted/build_and_install/build_from_source_cn.html">从源码编译</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../getstarted/concepts/use_concepts_cn.html">基本使用概念</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../howto/index_cn.html">进阶指南</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../howto/usage/cmd_parameter/index_cn.html">设置命令行参数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../howto/usage/cmd_parameter/use_case_cn.html">使用案例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/usage/cmd_parameter/arguments_cn.html">参数概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/usage/cmd_parameter/detail_introduction_cn.html">细节描述</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../howto/usage/cluster/cluster_train_cn.html">分布式训练</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../howto/usage/cluster/fabric_cn.html">fabric集群</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/usage/cluster/openmpi_cn.html">openmpi集群</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/usage/cluster/k8s_cn.html">kubernetes单机</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/usage/cluster/k8s_distributed_cn.html">kubernetes distributed分布式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/usage/cluster/k8s_aws_cn.html">AWS上运行kubernetes集群训练</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../howto/usage/capi/index_cn.html">PaddlePaddle C-API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../howto/usage/capi/compile_paddle_lib_cn.html">编译 PaddlePaddle 预测库</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/usage/capi/organization_of_the_inputs_cn.html">输入/输出数据组织</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/usage/capi/workflow_of_capi_cn.html">C-API 使用流程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../howto/dev/contribute_to_paddle_cn.html">如何贡献代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../howto/dev/write_docs_cn.html">如何贡献/修改文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../howto/deep_model/rnn/index_cn.html">RNN相关模型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../howto/deep_model/rnn/rnn_config_cn.html">RNN配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/deep_model/rnn/recurrent_group_cn.html">Recurrent Group教程</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/deep_model/rnn/hierarchical_layer_cn.html">支持双层序列作为输入的Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/deep_model/rnn/hrnn_rnn_api_compare_cn.html">单双层RNN API对比介绍</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../howto/optimization/gpu_profiling_cn.html">GPU性能分析与调优</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/index_cn.html">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../api/v2/model_configs.html">模型配置</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/config/activation.html">Activation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/config/layer.html">Layers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/config/evaluators.html">Evaluators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/config/optimizer.html">Optimizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/config/pooling.html">Pooling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/config/networks.html">Networks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/config/attr.html">Parameter Attribute</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../api/v2/data.html">数据访问</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/data/data_reader.html">Data Reader Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/data/image.html">Image Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/data/dataset.html">Dataset</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../api/v2/run_logic.html">训练与应用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/v2/fluid.html">Fluid</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/fluid/layers.html">layers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/fluid/data_feeder.html">data_feeder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/fluid/executor.html">executor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/fluid/initializer.html">initializer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/fluid/evaluator.html">evaluator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/fluid/nets.html">nets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/fluid/optimizer.html">optimizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/fluid/param_attr.html">param_attr</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/fluid/profiler.html">profiler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/fluid/regularizer.html">regularizer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api/v2/fluid/io.html">io</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index_cn.html">FAQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq/build_and_install/index_cn.html">编译安装与单元测试</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/model/index_cn.html">模型配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/parameter/index_cn.html">参数设置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/local/index_cn.html">本地训练与预测</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/cluster/index_cn.html">集群训练与预测</a></li>
</ul>
</li>
</ul>

        
    </nav>
    
    <section class="doc-content-wrap">

      

 







<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
      
    <li>Design Doc: CSP in PaddlePaddle Fluid</li>
  </ul>
</div>
      
      <div class="wy-nav-content" id="doc-content">
        <div class="rst-content">
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="design-doc-csp-in-paddlepaddle-fluid">
<span id="design-doc-csp-in-paddlepaddle-fluid"></span><h1>Design Doc: CSP in PaddlePaddle Fluid<a class="headerlink" href="#design-doc-csp-in-paddlepaddle-fluid" title="永久链接至标题">¶</a></h1>
<div class="section" id="motivation">
<span id="motivation"></span><h2>Motivation<a class="headerlink" href="#motivation" title="永久链接至标题">¶</a></h2>
<p>Concurrent programming is important for deep learning.  Few example applications are:</p>
<ol class="simple">
<li>The main thread keeps reading the next mini-batch while another thread uses the GPU for computing.</li>
<li>The main thread performs the computation while another thread uploads the local gradients from each trainer to the parameter server.</li>
</ol>
<p>Most DL systems, including TensorFlow, Caffe2, and MxNet, can asynchronously execute operators in a graph. However, Fluid doesn&#8217;t have the concept of a graph at all, as the design goal of Fluid is that of a programming language.</p>
</div>
<div class="section" id="concurrent-programming-models">
<span id="concurrent-programming-models"></span><h2>Concurrent Programming Models<a class="headerlink" href="#concurrent-programming-models" title="永久链接至标题">¶</a></h2>
<p>There were many concurrent programming models, implemented in various forms:</p>
<p>| concurrent programming model | implementation |
|&#8212;&#8211;|&#8212;&#8211;|
| mutex | types and functions in standard libraries |
| semaphore | types and functions in standard libraries |
| communicating sequential processes (CSP) | Go programming language |
| actor model | Erlang programming language |
| message passing | MPI |
| bulk synchronous parallel (BSP) | Pregel distributed programming framework |</p>
<p>Since Fluid was designed to be a programming language, we would like to implement CSP in Fluid.</p>
<div class="section" id="csp-v-s-actor-model">
<span id="csp-v-s-actor-model"></span><h3>CSP v.s. Actor Model<a class="headerlink" href="#csp-v-s-actor-model" title="永久链接至标题">¶</a></h3>
<p>A well-known implementation of Actor Model is the Erlang programming language.  In Actor Model, <em>processes</em> could send messages to another process and receive messages from another process given the process IDs.  We can find the three ingredients, process with ID, send, and recv, in MPI too.  Indeed, we can rewrite Erlang programs in Python + MPI with possibly fewer lines of code.  Our concern with Actor Model is that it doesn&#8217;t seem reasonable to implement process management in a programming language&#8217;s runtime library; instead, it should be the operating systems&#8217; responsibility to manage processes and libraries like MPI for send/recv.</p>
</div>
</div>
<div class="section" id="csp-in-fluid">
<span id="csp-in-fluid"></span><h2>CSP in Fluid<a class="headerlink" href="#csp-in-fluid" title="永久链接至标题">¶</a></h2>
<p>Fluid has two fundamental control-flows: <em>if-else</em> and <em>while</em>.  If we are to implement CSP, we need the following:</p>
<ol class="simple">
<li>a new data type: <em>channel</em> and operators <em>send</em> and <em>recv</em>,</li>
<li><em>goroutine</em> or thread, and</li>
<li>a new control-flow: select.</li>
</ol>
<p>We also need Python wrappers for the above components.</p>
<p>The type <em>channel</em> is conceptually the blocking queue.  In Go, its implemented is a <a class="reference external" href="https://github.com/golang/go/blob/68ce117cf17b8debf5754bfd476345779b5b6616/src/runtime/chan.go#L31-L50">blocking circular queue</a>, which supports send and recv.</p>
<p>The <code class="docutils literal"><span class="pre">select</span></code> operation has been in OS kernels long before Go language.  All Unix kernels implement system calls <em>poll</em> and <em>select</em>.  They monitor multiple file descriptors to see if I/O is possible on any of them.  This takes O(N) time.  Since Linux 2.6, a new system call, <em>epoll</em>, can do the same in O(1) time.  In BSD systems, there is a similar system call <em>kqueue</em>.  Go&#8217;s Linux implementation uses epoll.</p>
<p>It might be a good idea to implement Fluid&#8217;s select using epoll too.  In this design doc, we start from the O(N) way, so we could focus on Python binding and the syntax.</p>
<div class="section" id="type-channel">
<span id="type-channel"></span><h3>Type Channel<a class="headerlink" href="#type-channel" title="永久链接至标题">¶</a></h3>
<p>Fluid supports many data types:</p>
<ol class="simple">
<li>Tensor,</li>
<li>Row-sparse Tensor</li>
<li>LoD Tensor,</li>
<li>Tensor array, etc</li>
</ol>
<p>Each data type is registered in the <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/framework/framework.proto#L117-L127"><code class="docutils literal"><span class="pre">framework.proto</span></code></a> as an enum value.  To add a new type channel, we need to add a new type enum.</p>
<p>To expose a C++ type to Python, we need to edit the <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/pybind/pybind.cc"><code class="docutils literal"><span class="pre">pybind.cc</span></code></a> file.  <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/pybind/pybind.cc#L120-L164">Here</a> is an example how we expose C++ class LoDTensor.</p>
</div>
</div>
<div class="section" id="syntax-design">
<span id="syntax-design"></span><h2>Syntax Design<a class="headerlink" href="#syntax-design" title="永久链接至标题">¶</a></h2>
<div class="section" id="create-channel">
<span id="create-channel"></span><h3>Create Channel<a class="headerlink" href="#create-channel" title="永久链接至标题">¶</a></h3>
<p>In Go, we create a channel by specifying the element type and buffer size:</p>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="nx">ch</span>  <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>       <span class="c1">// a channel without buffer</span>
<span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1">// a channel that can buffer 100 ints.</span>
</pre></div>
</div>
<p>In Fluid, we should be able to do the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">ch</span>  <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">make_channel</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">INT</span><span class="p">)</span>
<span class="n">ch1</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">make_channel</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">INT</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to that, we want channels that can hold more complex element types, e.g., Tensors of float16:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">ch</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">make_channel</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">etype</span><span class="o">=</span><span class="n">float16</span><span class="p">)</span>
</pre></div>
</div>
<p>or Tensors of Tensors of float16 etc.</p>
<p>The point here is that we need a consistent way to compose types, like in C++ we can have <code class="docutils literal"><span class="pre">Tensor&lt;Tensor&lt;...&lt;float16&gt;...&gt;</span> <span class="pre">&gt;</span></code>.</p>
</div>
<div class="section" id="send-and-recv">
<span id="send-and-recv"></span><h3>Send and Recv<a class="headerlink" href="#send-and-recv" title="永久链接至标题">¶</a></h3>
<p>In Go, we first create a channel as explained in the section above and then perform read and write operations on top of the channels.</p>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="nx">ch1</span>  <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>       
<span class="nx">ch2</span>  <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>To write (or perform a <code class="docutils literal"><span class="pre">Send</span></code> operation) the value of a variable <code class="docutils literal"><span class="pre">x</span></code>, to channel <code class="docutils literal"><span class="pre">ch1</span></code> above, we perform the following:</p>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="nx">ch1</span> <span class="o">&lt;-</span> <span class="nx">x</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Written to the channel&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now to read (or perform a <code class="docutils literal"><span class="pre">Recv</span></code> operation) the value stored in <code class="docutils literal"><span class="pre">ch2</span></code> into a variable <code class="docutils literal"><span class="pre">y</span></code>, we perform the following:</p>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="nx">y</span> <span class="o">&lt;-</span> <span class="nx">ch2</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Received from channel&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In Fluid, we should be able to perform the above operations on the channel objects as well. As of now, we support two different kinds of channels : <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/framework/details/buffered_channel.h">Buffered Channel</a> and <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/paddle/framework/details/unbuffered_channel.h">UnBuffered Channel</a></p>
<p>Send and Receive can be performed as following on a buffered channel:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="k">def</span> <span class="nf">send_to_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">num_time</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_time</span><span class="p">):</span>
    <span class="n">channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="c1"># Create a buffered channel of capacity 10</span>
<span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">ch</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">make_channel</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">INT</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>

<span class="c1"># Now write three elements to the channel</span>
<span class="n">thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">send_to_channel</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">))</span>
<span class="n">thread</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># Read all the data from the channel</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>

<span class="c1"># Done receiving , now close the channel</span>
<span class="n">ch</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>The send and receive operations will be similar for unbuffered channel as well, except for the fact that there is no buffer in an unbuffered channel, so the operations are completely synchronized. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">threading</span>

<span class="k">def</span> <span class="nf">send_to_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
  <span class="n">channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># Create an unbuffered channel</span>
<span class="n">ch</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">make_channel</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">INT</span><span class="p">)</span>

<span class="c1"># Writes and Reads are synchronous otherwise the calls will block.</span>
<span class="n">thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">send_to_channel</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">))</span>
<span class="n">thread</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>

<span class="c1"># Done receiving , now close the channel</span>
<span class="n">ch</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="select">
<span id="select"></span><h3>Select<a class="headerlink" href="#select" title="永久链接至标题">¶</a></h3>
<p>In Go, the <code class="docutils literal"><span class="pre">select</span></code> statement lets a goroutine wait on multiple communication operations. A <code class="docutils literal"><span class="pre">select</span></code> blocks untill one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.</p>
<div class="highlight-go"><div class="highlight"><pre><span></span><span class="nx">ch1</span>  <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>       
<span class="nx">ch2</span>  <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="p">{</span>
    <span class="k">select</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">ch1</span> <span class="o">&lt;-</span> <span class="nx">x</span><span class="p">:</span>
      <span class="nx">x</span> <span class="o">:=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">case</span> <span class="nx">y</span> <span class="o">&lt;-</span> <span class="nx">ch2</span><span class="p">:</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Received on channel&quot;</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Default&quot;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>In Fluid, we should be able to do the same:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">ch1</span>  <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">make_chan</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">INT</span><span class="p">)</span>
<span class="n">ch2</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">make_chan</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">INT</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="n">sel</span> <span class="o">=</span> <span class="n">fluid</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>

<span class="k">with</span> <span class="n">sel</span><span class="o">.</span><span class="n">case</span><span class="p">(</span><span class="n">ch1</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
    <span class="n">fluid</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">increment</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="k">with</span> <span class="n">sel</span><span class="o">.</span><span class="n">case</span><span class="p">(</span><span class="n">ch2</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
    <span class="n">fluid</span><span class="o">.</span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;Received on Channel&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">sel</span><span class="o">.</span><span class="n">default</span><span class="p">():</span>
    <span class="n">fluid</span><span class="o">.</span><span class="k">print</span><span class="p">(</span><span class="s2">&quot;Default&quot;</span><span class="p">)</span>

</pre></div>
</div>
<p>In the above code snippet, <code class="docutils literal"><span class="pre">X</span></code> and <code class="docutils literal"><span class="pre">Y</span></code> are variables. Now let us look at each of these statements one by one.</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">sel.case(ch1,</span> <span class="pre">'w',</span> <span class="pre">X)</span></code> : This specifies that we are writing to <code class="docutils literal"><span class="pre">ch1</span></code> and we want to write the integer in variable <code class="docutils literal"><span class="pre">X</span></code> to the channel. The character <code class="docutils literal"><span class="pre">w</span></code> is used here to make the syntax familar to write syntax in Python I/O.</li>
<li><code class="docutils literal"><span class="pre">sel.case(ch2,</span> <span class="pre">'r',</span> <span class="pre">Y)</span></code> : This specifies that we would like to read the result from <code class="docutils literal"><span class="pre">ch2</span></code> into variable <code class="docutils literal"><span class="pre">Y</span></code>. The character <code class="docutils literal"><span class="pre">r</span></code> is used here to make the syntax familar to read syntax in Python I/O.</li>
<li><code class="docutils literal"><span class="pre">sel.default()</span></code> : This is equivalent to the default in Go <code class="docutils literal"><span class="pre">select</span></code>. If none of the channels are ready for read or write, then the fluid code in the default block will be executed.</li>
</ul>
</div>
</div>
<div class="section" id="example-programs">
<span id="example-programs"></span><h2>Example Programs<a class="headerlink" href="#example-programs" title="永久链接至标题">¶</a></h2>
<div class="section" id="rpc-between-trainers-and-parameter-servers">
<span id="rpc-between-trainers-and-parameter-servers"></span><h3>1. RPC between Trainers and Parameter Servers<a class="headerlink" href="#rpc-between-trainers-and-parameter-servers" title="永久链接至标题">¶</a></h3>
</div>
<div class="section" id="concurrent-minibatch-loading">
<span id="concurrent-minibatch-loading"></span><h3>2. Concurrent Minibatch Loading<a class="headerlink" href="#concurrent-minibatch-loading" title="永久链接至标题">¶</a></h3>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, PaddlePaddle developers.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ".txt",
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>
       
  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  
  
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/perfect-scrollbar/0.6.14/js/perfect-scrollbar.jquery.min.js"></script>
  <script src="../_static/js/paddle_doc_init.js"></script> 

</body>
</html>