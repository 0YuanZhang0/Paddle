

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Introduction &mdash; PaddlePaddle  文档</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
  
        <link rel="index" title="索引"
              href="../genindex.html"/>
        <link rel="search" title="搜索" href="../search.html"/>
    <link rel="top" title="PaddlePaddle  文档" href="../index.html"/> 

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/perfect-scrollbar/0.6.14/css/perfect-scrollbar.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/override.css" type="text/css" />
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?b9a314ab40d04d805655aab1deee08ba";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>

  

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  
  <header class="site-header">
    <div class="site-logo">
      <a href="/"><img src="../_static/images/PP_w.png"></a>
    </div>
    <div class="site-nav-links">
      <div class="site-menu">
        <a class="fork-on-github" href="https://github.com/PaddlePaddle/Paddle" target="_blank"><i class="fa fa-github"></i>Fork me on Github</a>
        <div class="language-switcher dropdown">
          <a type="button" data-toggle="dropdown">
            <span>English</span>
            <i class="fa fa-angle-up"></i>
            <i class="fa fa-angle-down"></i>
          </a>
          <ul class="dropdown-menu">
            <li><a href="/doc_cn">中文</a></li>
            <li><a href="/doc">English</a></li>
          </ul>
        </div>
        <ul class="site-page-links">
          <li><a href="/">Home</a></li>
        </ul>
      </div>
      <div class="doc-module">
        
        <ul>
<li class="toctree-l1"><a class="reference internal" href="../getstarted/index_cn.html">新手入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../build_and_install/index_cn.html">安装与编译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../howto/index_cn.html">进阶使用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/index_cn.html">开发标准</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index_cn.html">FAQ</a></li>
</ul>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>        
      </div>
    </div>
  </header>
  
  <div class="main-content-wrap">

    
    <nav class="doc-menu-vertical" role="navigation">
        
          
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../getstarted/index_cn.html">新手入门</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getstarted/quickstart_cn.html">快速开始</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getstarted/concepts/use_concepts_cn.html">基本使用概念</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../build_and_install/index_cn.html">安装与编译</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../build_and_install/pip_install_cn.html">使用pip安装</a></li>
<li class="toctree-l2"><a class="reference internal" href="../build_and_install/docker_install_cn.html">使用Docker安装运行</a></li>
<li class="toctree-l2"><a class="reference internal" href="../build_and_install/build_from_source_cn.html">从源码编译</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../howto/index_cn.html">进阶使用</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../howto/cmd_parameter/index_cn.html">命令行参数设置</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../howto/cmd_parameter/use_case_cn.html">使用案例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/cmd_parameter/arguments_cn.html">参数概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/cmd_parameter/detail_introduction_cn.html">细节描述</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../howto/cluster/index_cn.html">分布式训练</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../howto/cluster/preparations_cn.html">环境准备</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/cluster/cmd_argument_cn.html">启动参数说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/cluster/multi_cluster/index_cn.html">在不同集群中运行</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../howto/cluster/multi_cluster/fabric_cn.html">使用fabric启动集群训练</a></li>
<li class="toctree-l4"><a class="reference internal" href="../howto/cluster/multi_cluster/openmpi_cn.html">在OpenMPI集群中提交训练作业</a></li>
<li class="toctree-l4"><a class="reference internal" href="../howto/cluster/multi_cluster/k8s_cn.html">Kubernetes单机训练</a></li>
<li class="toctree-l4"><a class="reference internal" href="../howto/cluster/multi_cluster/k8s_distributed_cn.html">Kubernetes分布式训练</a></li>
<li class="toctree-l4"><a class="reference internal" href="../howto/cluster/multi_cluster/k8s_aws_cn.html">Distributed PaddlePaddle Training on AWS with Kubernetes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../howto/capi/index_cn.html">C-API预测库</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../howto/capi/compile_paddle_lib_cn.html">安装与编译C-API预测库</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/capi/organization_of_the_inputs_cn.html">输入/输出数据组织</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/capi/workflow_of_capi_cn.html">C-API使用流程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../howto/rnn/index_cn.html">RNN模型</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../howto/rnn/rnn_config_cn.html">RNN配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/rnn/recurrent_group_cn.html">Recurrent Group教程</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/rnn/hierarchical_layer_cn.html">支持双层序列作为输入的Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../howto/rnn/hrnn_rnn_api_compare_cn.html">单双层RNN API对比介绍</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../howto/optimization/gpu_profiling_cn.html">GPU性能调优</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../dev/index_cn.html">开发标准</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../dev/contribute_to_paddle_cn.html">如何贡献代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dev/write_docs_cn.html">如何贡献文档</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index_cn.html">FAQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq/build_and_install/index_cn.html">编译安装与单元测试</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/model/index_cn.html">模型配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/parameter/index_cn.html">参数设置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/local/index_cn.html">本地训练与预测</a></li>
<li class="toctree-l2"><a class="reference internal" href="../faq/cluster/index_cn.html">集群训练与预测</a></li>
</ul>
</li>
</ul>

        
    </nav>
    
    <section class="doc-content-wrap">

      

 







<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
      
    <li>Introduction</li>
  </ul>
</div>
      
      <div class="wy-nav-content" id="doc-content">
        <div class="rst-content">
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="introduction">
<span id="introduction"></span><h1>Introduction<a class="headerlink" href="#introduction" title="永久链接至标题">¶</a></h1>
<p>There are many performance analysis tools for <a class="reference external" href="https://en.wikipedia.org/wiki/List_of_performance_analysis_tools">different programming languages and different software frameworks</a>. For most popular deep learning frameworks, they use several programming languages and adapt to heterogeneous platforms. Similar to most of the deep learning frameworks, PaddlePaddle also uses C++, CUDA and Python as the basic programming languages to adapt to run on CPU and GPU devices.  The <a class="reference external" href="http://docs.nvidia.com/cuda/profiler-users-guide/index.html#nvprof-overview"><code class="docutils literal"><span class="pre">nvprof</span></code> tools</a> is usually used to analyse the CUDA program.  We have <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/doc/howto/optimization/cpu_profiling.md">a document</a> to profile CPU and Python program by <a class="reference external" href="https://pypi.python.org/pypi/yep">yep</a> and <a class="reference external" href="https://github.com/google/pprof">Google&#8217;s perftools</a> to profile only the CPU and Python program. But for <a class="reference external" href="https://github.com/PaddlePaddle/Paddle/blob/develop/doc/design/fluid.md">PaddlePaddle fluid</a>, the operator is the basic computing unit. The developers usually want to collect the time of each operator and locate bottlenecks.  The <code class="docutils literal"><span class="pre">nvprof</span></code> usually collect the timeline of CUDA-related activities on both CPU and GPU, including kernel execution, memory transfers, memory set and CUDA API calls and events or metrics for CUDA kernels. And the <code class="docutils literal"><span class="pre">yep</span></code> and <code class="docutils literal"><span class="pre">Google's</span> <span class="pre">perftools</span></code> can&#8217;t collect the timeline for CUDA program. All these tools can&#8217;t collect time in the operator level. So we design this profiling tool.</p>
</div>
<div class="section" id="architecture">
<span id="architecture"></span><h1>Architecture<a class="headerlink" href="#architecture" title="永久链接至标题">¶</a></h1>
<p>The work flow for most task is as follows. Each operator will run many times in the all iterations. So the profiler must collect the total time of each operator during the iteration. For more, sometimes, the developers may want to collect more detailed time span inside the operator or record time span for elsewhere, this requires that the profiler must support to record the nested time span. And in order to speedup training, all the deep learning frameworks support parallel computing, including multiple threads on CPU and multiple GPUs. So the profiler must be able to collect the timeline for each thread. In addition, the profiler also occupies certain resources. It must can be easily to be enabled or disabled by the developers. At last, the profiler should present a human-readable report.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>  <span class="c1"># M is  the iteration number</span>
  <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operator_lists</span><span class="p">:</span> <span class="c1"># The `operator_lists` contains all the operators in the network.</span>
    <span class="n">op</span><span class="o">.</span><span class="n">run</span><span class="p">();</span>
</pre></div>
</div>
<p>In summary, the proflier should have following features:</p>
<ul class="simple">
<li>records time span in loop.</li>
<li>supports nested time span.</li>
<li>supports multiple threads/multiple GPUs.</li>
<li>supports to be enabled and disabled by users.</li>
</ul>
<p>But how to record the time for the mixed C++ and CUDA program?  There many C++ APIs to get the current calendar time in host program. But for GPU, the CUDA kernels may be executed concurrently if they are in different <a class="reference external" href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#streams">streams</a> and the CUDA kernels is asynchronous with the host program if there is no the synchronous aftern the CUDA kernels. CUDA provides <a class="reference external" href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#events">event</a> to monitor the device and perform accurate timing. Inspired by PyTorch and CUDA event, we also design and apply the events to record the timeline. Then summarize and present statistics based on these events.</p>
<p>The overall flow is shown as the following figure.</p>
<p><img src="./images/profiler.png" align="center"/><br/></p>
<div class="section" id="event">
<span id="event"></span><h2>Event<a class="headerlink" href="#event" title="永久链接至标题">¶</a></h2>
<p>In above work flow, a pair of events are needed before and after the piece of code to collect time. So the event has a flag to mark whether it is a starting event or an ending event. Except this two kinds of event, sometime, a only marker with a text message&nbsp;is needed, for example, a marker to specify the profiling start or end. There are three kinds of event:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">EventKind</span> <span class="p">{</span>
  <span class="n">kMark</span><span class="p">,</span>
  <span class="n">kPushRange</span><span class="p">,</span>
  <span class="n">kPopRange</span><span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>kMark: only a marker without time range.</li>
<li>kPushRange: mark the starting event for time range.</li>
<li>kPopRange: mark the ending event for time range.</li>
</ul>
<p>For the CPU code, the events only need to record the current time. For the CUDA code, the <a class="reference external" href="http://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__EVENT.html#group__CUDART__EVENT">event management functions of CUDA</a> are used.  For many pieces of code, an event lists are used to record each piece.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Event</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// The DeviceContext is used to get current  CUDA stream.</span>
  <span class="n">Event</span><span class="p">(</span><span class="n">EventKind</span> <span class="n">kind</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">thread_id</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">platform</span><span class="o">::</span><span class="n">DeviceContext</span><span class="o">*</span> <span class="n">dev_ctx</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">);</span>
  <span class="kt">double</span> <span class="nf">CpuElapsedUs</span><span class="p">(</span><span class="k">const</span> <span class="n">Event</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">double</span> <span class="nf">CudaElapsedUs</span><span class="p">(</span><span class="k">const</span> <span class="n">Event</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">EventKind</span> <span class="n">kind_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">thread_id_</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">cpu_ns_</span><span class="p">;</span>
<span class="cp">#ifdef PADDLE_WITH_CUDA</span>
  <span class="n">cudaEvent_t</span> <span class="n">event_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">device_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">EventList</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Event</span><span class="o">&gt;&gt;</span> <span class="n">event_blocks</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As mentioned above, there is no need to record the timeline when disabling the profiler. So there is a global state to enable or disable the profiler.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">ProfilerState</span> <span class="p">{</span>
  <span class="n">kDisabled</span><span class="p">,</span> 
  <span class="n">kCPU</span><span class="p">,</span>
  <span class="n">kCUDA</span>
<span class="p">};</span>
<span class="n">ProfilerState</span> <span class="n">g_state</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>kDisabled: the disabled state.</li>
<li>kCPU: CPU profiling state.</li>
<li>kCUDA: GPU profiling state.</li>
</ul>
<p>A pair of starting and ending events are pushed to event lists in constructor and destructor of <code class="docutils literal"><span class="pre">RecordEvent</span></code>. So the timeline is recorded for the code in the lifecycle of an object of <code class="docutils literal"><span class="pre">RecordEvent</span></code>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">RecordEvent</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="n">RecordEvent</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span>
                       <span class="n">platform</span><span class="o">::</span><span class="n">DeviceContext</span><span class="o">*</span> <span class="n">dev_ctx</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">kState</span> <span class="o">==</span> <span class="n">ProfilerState</span><span class="o">::</span><span class="n">kDisabled</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="c1">// push the starting event to the event lists.</span>
  <span class="p">}</span>
  <span class="o">~</span><span class="n">RecordEvent</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">kState</span> <span class="o">==</span> <span class="n">ProfilerState</span><span class="o">::</span><span class="n">kDisabled</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="c1">// push the ending event to the event lists.</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, PaddlePaddle developers.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: ".txt",
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>
       
  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  
  
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/perfect-scrollbar/0.6.14/js/perfect-scrollbar.jquery.min.js"></script>
  <script src="../_static/js/paddle_doc_init.js"></script> 

</body>
</html>